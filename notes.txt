
Logical:
	[+] WHILE
	[+]	JI // jump if true | JI (expression)
	[+] JN
	[+] JU
	[+] PRINT
	[+] PUT
	[+] VAR

	[+] expression evaluation:
		[+] recursive eval from right
		[+] can reference variable
		[+] do single char operations {'+', '-', '/', '*', ..} 
		[+] {"==", "<=", ">=", .. does not work due to current way of parsing}

		expression = (expression_) {&, |} (expression_) ...
		atomic_expression = (x {<,=,>} 1) (d {<,=,>} e) : x,d,e can be expressions but theres no {&,|} 

Commands:
	Called with:
	[+] CALL command [args...]

	[+] Move([R|L], duration=delta)  : amount of movement determined by character speed, if you use this with distance {duration = dist/GetSpeedDir} can be used

	[+]	Jump(strength) : strength=clamp(strength, 0, 1)

	[-] ProjectileAttack(direction2D)

Queries:
	[+] GetDist_U, GetDist_L, ..
	[-] GetVel


Code example:
go until you hit a wall
jump when you hit a wall
-> ___----____

0	FLAG_0 {flag}
1	Move r 
2	JI (GetDist_R > 0.1) FLAG_0
3	Jump(1)
4	Move r

Expression parsing:
(GD_R>9)*(GD_DR<9)

TO_DO:
	[+] add VAR
	[+] make PRINT work with queries and variables
	[+] CALL STOP





VAR F1 0
VAR STOPPED 0
JI STOPPED STOPPING
JI GD_R < 1 SKIP
JI (GD_DR > 4) && (GD_D < 1) STOPPING
CALL MOVE R
PUT F1 (F1+1)
JU DONT_JUMP
SKIP
CALL JUMP 1
DONT_JUMP
JU END
STOPPING
PUT STOPPED 1
CALL STOP
END